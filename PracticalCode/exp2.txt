EXP 2) Implement a stack data structure using arrays and 
linked list.

# Stack Implementation Using Arrays
#include <iostream>
#define MAX 100

class StackArray {
private:
    int arr[MAX];
    int top;

public:
    StackArray() {
        top = -1; // Initialize top of the stack
    }

    void push(int x) {
        if (top >= MAX - 1) {
            std::cout << "Stack Overflow\n";
            return;
        }
        arr[++top] = x; // Increment top and add element
    }

    void pop() {
        if (top < 0) {
            std::cout << "Stack Underflow\n";
            return;
        }
        top--; // Decrement top to remove the element
    }

    int peek() {
        if (top < 0) {
            std::cout << "Stack is empty\n";
            return -1; // Indicating an empty stack
        }
        return arr[top]; // Return the top element
    }

    bool isEmpty() {
        return top < 0; // Return true if stack is empty
    }

    void display() {
        if (isEmpty()) {
            std::cout << "Stack is empty\n";
            return;
        }
        for (int i = top; i >= 0; i--) {
            std::cout << arr[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    StackArray stack;
    stack.push(10);
    stack.push(20);
    stack.push(30);
    
    stack.display();
    
    std::cout << "Top element is " << stack.peek() << std::endl;
    
    stack.pop();
    stack.display();
    
    return 0;
}

# Stack Implementation Using Linked Lists

#include <iostream>

class Node {
public:
    int data;
    Node* next;
    
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

class StackLinkedList {
private:
    Node* top;

public:
    StackLinkedList() {
        top = nullptr; // Initialize top of the stack
    }

    void push(int x) {
        Node* newNode = new Node(x);
        newNode->next = top; // Link new node to the previous top
        top = newNode; // Update top to the new node
    }

    void pop() {
        if (top == nullptr) {
            std::cout << "Stack Underflow\n";
            return;
        }
        Node* temp = top; // Store the current top
        top = top->next; // Update top to the next node
        delete temp; // Free memory of the old top
    }

    int peek() {
        if (top == nullptr) {
            std::cout << "Stack is empty\n";
            return -1; // Indicating an empty stack
        }
        return top->data; // Return the top element
    }

    bool isEmpty() {
        return top == nullptr; // Return true if stack is empty
    }

    void display() {
        if (isEmpty()) {
            std::cout << "Stack is empty\n";
            return;
        }
        Node* current = top;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next; // Move to the next node
        }
        std::cout << std::endl;
    }
};

int main() {
    StackLinkedList stack;
    stack.push(10);
    stack.push(20);
    stack.push(30);
    
    stack.display();
    
    std::cout << "Top element is " << stack.peek() << std::endl;
    
    stack.pop();
    stack.display();
    
    return 0;
}





